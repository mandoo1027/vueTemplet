"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ViteWebfontDownload: () => viteWebfontDownload,
  default: () => viteWebfontDownload,
  viteWebfontDl: () => viteWebfontDownload,
  viteWebfontDownload: () => viteWebfontDownload,
  webfontDl: () => viteWebfontDownload,
  webfontDownload: () => viteWebfontDownload
});
module.exports = __toCommonJS(src_exports);
var import_http2 = require("http");
var import_picocolors3 = __toESM(require("picocolors"));

// src/css-loader.ts
var import_url = require("url");
var import_clean_css = __toESM(require("clean-css"));
var CssLoader = class {
  constructor(options, logger, downloader, fileCache) {
    this.options = options;
    this.logger = logger;
    this.downloader = downloader;
    this.fileCache = fileCache;
    this.isRelativeUrlRegex = /\.\.?\/[-a-z0-9@:%_+.~#?&/=]+\.(?:woff2?|eot|ttf|otf|svg)/gi;
    this.protocolRelativeUrlRegex = new RegExp("(?<!https?:)\\/\\/[-a-z0-9@:%_+.~#?&/=]+\\.(?:woff2?|eot|ttf|otf|svg)", "gi");
  }
  loadAll(urls, isDevServer) {
    return __async(this, null, function* () {
      let cssContent = "";
      for (const url of urls) {
        const css = yield this.load(url);
        const cssNormalized = this.normalizeUrls(css.trim(), url);
        cssContent += cssNormalized + "\n";
      }
      return this.formatCss(cssContent, isDevServer);
    });
  }
  formatCss(cssContent, isDevServer) {
    if (!isDevServer && this.options.minifyCss) {
      return this.minify(cssContent);
    }
    return cssContent.trim();
  }
  minify(cssContent) {
    return new import_clean_css.default().minify(cssContent).styles;
  }
  normalizeUrls(cssContent, cssUrl) {
    cssContent = cssContent.replaceAll(this.isRelativeUrlRegex, (match) => {
      const urlObject = new import_url.URL(match, cssUrl);
      return urlObject.href;
    });
    cssContent = cssContent.replaceAll(this.protocolRelativeUrlRegex, (match) => {
      return "https:" + match;
    });
    return cssContent;
  }
  load(url) {
    return __async(this, null, function* () {
      this.logger.flashLine(url);
      const cachedFile = this.fileCache.get("css", url);
      if (cachedFile) {
        return cachedFile;
      }
      const response = yield this.downloader.download(url, "text");
      this.fileCache.save("css", url, response.data);
      return response.data;
    });
  }
};

// src/css-parser.ts
var CssParser = class {
  constructor() {
    this.fontSrcRegex = /(?:https?:)?\/\/[-a-z0-9@:%_+.~#?&/=]+\.(?:woff2?|eot|ttf|otf|svg)/gi;
    this.googleFontsKitSrcRegex = /https:\/\/fonts\.gstatic\.com\/l\/font\?kit=[a-z0-9&=_-]+/gi;
    this.fontFilenameRegex = /[^/]+\.(?:woff2?|eot|ttf|otf|svg)/i;
    this.googleFontsFileRegex = /\?kit=([a-z0-9_-]+)/i;
    // @font-face { src: url('...'); }
    // @import url('...');
    this.webfontProviders = [
      /https:\/\/fonts\.googleapis\.com\//i,
      /https:\/\/fonts\.gstatic\.com\//i,
      /https:\/\/fonts\.bunny\.net\//i,
      /https:\/\/api\.fontshare\.com\//i
    ];
  }
  parse(cssContent, base, assetsDir) {
    var _a, _b;
    const fonts = {};
    const fontSrcMatches = cssContent.matchAll(this.fontSrcRegex);
    const googleFontsKitSrcMatches = cssContent.matchAll(this.googleFontsKitSrcRegex);
    if (fontSrcMatches) {
      for (const fontSrcMatch of fontSrcMatches) {
        const url = fontSrcMatch.toString();
        const filenameMatch = url.match(this.fontFilenameRegex);
        if (filenameMatch) {
          const filename = filenameMatch[0];
          fonts[filename] = {
            url,
            localPath: base + (assetsDir ? assetsDir + "/" : "") + filename
          };
        }
      }
    }
    if (googleFontsKitSrcMatches) {
      for (const googleFontsKitSrcMatch of googleFontsKitSrcMatches) {
        const url = googleFontsKitSrcMatch.toString();
        const filename = (_b = (_a = url.match(this.googleFontsFileRegex)) == null ? void 0 : _a[1]) == null ? void 0 : _b.toString();
        if (filename) {
          fonts[filename + ".woff2"] = {
            url,
            localPath: base + (assetsDir ? assetsDir + "/" : "") + filename + ".woff2"
          };
        }
      }
    }
    return fonts;
  }
  parseBundleCss(cssContent, base, assetsDir) {
    const fonts = {};
    const webfontUrlsCss = /* @__PURE__ */ new Set([]);
    const matchedCssParts = [];
    const importRegex = /@import\s*(?:url\()?['"]?([^\s'"]+)['"]?\)?;/g;
    const fontFaceRegex = /@font-face\s*{[^}]*}/g;
    const imports = [...cssContent.matchAll(importRegex)];
    const fontFaces = [...cssContent.matchAll(fontFaceRegex)];
    fontFaces.forEach((match) => {
      const fontFace = match[0];
      const parsedFonts = this.parse(fontFace, base, assetsDir);
      for (const filename in parsedFonts) {
        const font = parsedFonts[filename];
        if (this.webfontProviders.some((regex) => regex.test(font.url))) {
          fonts[filename] = font;
          matchedCssParts.push(match[0]);
        }
      }
    });
    imports.forEach((match) => {
      const url = match[1];
      if (this.webfontProviders.some((regex) => regex.test(url))) {
        webfontUrlsCss.add(url);
        matchedCssParts.push(match[0]);
      }
    });
    return {
      fonts,
      webfontUrlsCss,
      matchedCssParts
    };
  }
};

// src/css-injector.ts
var CssInjector = class {
  constructor(options) {
    this.options = options;
  }
  injectAsStylesheet(html, base, cssPath) {
    if (this.options.async) {
      return this.injectAsync(html, base, cssPath);
    } else {
      return this.injectSync(html, base, cssPath);
    }
  }
  injectAsStyleTag(html, cssContent) {
    if (this.options.minifyCss) {
      return html.replace(
        /(\n?)([ \t]*)<\/head>/,
        `$1$2$2<style>${cssContent}</style>$1$2</head>`
      );
    }
    return html.replace(
      /([ \t]*)<\/head>/,
      `$1$1<style>
${cssContent.replace(/^/gm, "$1$1$1")}
$1$1</style>
$1</head>`
    );
  }
  injectAsync(html, base, cssPath) {
    return html.replace(
      /([ \t]*)<\/head>/,
      `$1$1<link rel="preload" as="style" href="${base}${cssPath}">
$1$1<link rel="stylesheet" media="print" onload="this.onload=null;this.removeAttribute('media');" href="${base}${cssPath}">
$1</head>`
    );
  }
  injectSync(html, base, cssPath) {
    return html.replace(
      /([ \t]*)<\/head>/,
      `$1$1<link rel="preload" as="style" href="${base}${cssPath}">
$1$1<link rel="stylesheet" href="${base}${cssPath}">
$1</head>`
    );
  }
};

// src/css-transformer.ts
var CssTransformer = class {
  transform(cssContent, fonts) {
    for (const fontFile in fonts) {
      const font = fonts[fontFile];
      cssContent = cssContent.replaceAll(font.url, font.localPath);
    }
    return cssContent;
  }
};

// src/downloader.ts
var import_axios = require("axios");
var import_http = require("http");
var import_https = require("https");
var import_picocolors = __toESM(require("picocolors"));
var Downloader = class {
  constructor(options, logger) {
    this.options = options;
    this.logger = logger;
    this.userAgentWoff2 = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36";
    this.maxTries = 3;
    this.timeout = 2500;
    this.waitBeforeRetry = [25, 2500];
    this.axios = new import_axios.Axios({
      timeout: this.timeout,
      proxy: this.options.proxy,
      httpAgent: new import_http.Agent({
        keepAlive: true,
        family: 4
      }),
      httpsAgent: new import_https.Agent({
        keepAlive: true,
        family: 4
      })
    });
  }
  download(url, responseType, tries = 1) {
    return __async(this, null, function* () {
      try {
        const response = yield this.toRequest(url, responseType);
        if (tries > 1) {
          this.logger.info(
            import_picocolors.default.green(`\u2713 ${url}`) + " " + import_picocolors.default.dim(`(try #${tries})`)
          );
        }
        return response;
      } catch (err) {
        this.logger.error(
          import_picocolors.default.red(`\u2717 ${url}`) + " " + import_picocolors.default.dim(`(try #${tries})`) + ": " + ((0, import_axios.isAxiosError)(err) ? err.message : err)
        );
        if (tries < this.maxTries) {
          yield new Promise((r) => setTimeout(r, this.randomWaitInterval()));
          return this.download(url, responseType, tries + 1);
        } else {
          throw err;
        }
      }
    });
  }
  toRequest(url, responseType) {
    return this.axios.get(url, {
      headers: {
        "User-Agent": this.userAgentWoff2
      },
      responseType: responseType || "arraybuffer"
    });
  }
  randomWaitInterval() {
    return Math.floor(
      Math.random() * (this.waitBeforeRetry[0] - this.waitBeforeRetry[1] + 1) + this.waitBeforeRetry[1]
    );
  }
};

// src/font-loader.ts
var FontLoader = class {
  constructor(logger, downloader, fileCache) {
    this.logger = logger;
    this.downloader = downloader;
    this.fileCache = fileCache;
  }
  load(url) {
    return __async(this, null, function* () {
      this.logger.flashLine(url);
      const cachedFile = this.fileCache.get("font", url);
      if (cachedFile) {
        return cachedFile;
      }
      const response = yield this.downloader.download(url);
      this.fileCache.save("font", url, response.data);
      return response.data;
    });
  }
};

// src/file-cache.ts
var import_flat_cache = __toESM(require("flat-cache"));
var FileCache = class {
  constructor(options) {
    this.enabled = true;
    this.hits = {
      css: 0,
      font: 0
    };
    if (options.cache === false) {
      this.enabled = false;
    }
    this.storeCss = import_flat_cache.default.create("vite-plugin-webfont-dl__css");
    this.storeFont = import_flat_cache.default.create("vite-plugin-webfont-dl__font");
    if (!this.enabled) {
      this.clear();
    }
  }
  get(type, url) {
    if (!this.enabled) {
      return;
    }
    const cachedFile = type === "css" ? this.storeCss.getKey(url) : this.storeFont.getKey(url);
    if (cachedFile) {
      if (type === "css") {
        this.hits.css++;
      } else {
        this.hits.font++;
      }
      if (cachedFile.type !== void 0) {
        return Buffer.from(cachedFile.data);
      }
      return cachedFile;
    }
  }
  save(type, url, data) {
    if (!this.enabled) {
      return;
    }
    if (type === "css") {
      this.storeCss.setKey(url, data);
      this.storeCss.save(true);
    } else {
      this.storeFont.setKey(url, data);
      this.storeFont.save(true);
    }
  }
  clear() {
    import_flat_cache.default.clearCacheById("vite-plugin-webfont-dl__css");
    import_flat_cache.default.clearCacheById("vite-plugin-webfont-dl__font");
  }
};

// src/index-html-processor.ts
var IndexHtmlProcessor = class {
  constructor() {
    this.webfontRegexes = [
      // <link rel="stylesheet" href="...">
      // <link href="..." rel="stylesheet">
      // https://fonts.googleapis.com
      /<link[^>]+rel=['"]?stylesheet['"]?[^>]+href=['"]?(https:\/\/fonts\.googleapis\.com[^'">]+)['"]?[^>]*>/g,
      /<link[^>]+href=['"]?(https:\/\/fonts\.googleapis\.com[^'">]+)['"]?[^>]+rel=['"]?stylesheet['"]?[^>]*>/g,
      // https://fonts.bunny.net
      /<link[^>]+rel=['"]?stylesheet['"]?[^>]+href=['"]?(https:\/\/fonts\.bunny\.net[^'">]+)['"]?[^>]*>/g,
      /<link[^>]+href=['"]?(https:\/\/fonts\.bunny\.net[^'">]+)['"]?[^>]+rel=['"]?stylesheet['"]?[^>]*>/g,
      // https://api.fontshare.com
      /<link[^>]+rel=['"]?stylesheet['"]?[^>]+href=['"]?(https:\/\/api\.fontshare\.com[^'">]+)['"]?[^>]*>/g,
      /<link[^>]+href=['"]?(https:\/\/api\.fontshare\.com[^'">]+)['"]?[^>]+rel=['"]?stylesheet['"]?[^>]*>/g
    ];
    this.preconnectRegexes = [
      // <link rel="preconnect" href="...">
      // <link rel="preconnect" href="..." crossorigin>
      // <link href="..." rel="preconnect">
      // <link href="..." rel="preconnect" crossorigin>
      // https://fonts.googleapis.com
      /<link[^>]+rel=['"]?preconnect['"]?[^>]+href=['"]?https:\/\/fonts\.googleapis\.com['"]?[^>]*>/,
      /<link[^>]+href=['"]?https:\/\/fonts\.googleapis\.com['"]?[^>]+rel=['"]?preconnect['"]?[^>]*>/,
      // https://fonts.gstatic.com
      /<link[^>]+rel=['"]?preconnect['"]?[^>]+href=['"]?https:\/\/fonts\.gstatic\.com['"]?[^>]*>/,
      /<link[^>]+href=['"]?https:\/\/fonts\.gstatic\.com['"]?[^>]+rel=['"]?preconnect['"]?[^>]*>/,
      // https://fonts.bunny.net
      /<link[^>]+rel=['"]?preconnect['"]?[^>]+href=['"]?https:\/\/fonts\.bunny\.net['"]?[^>]*>/,
      /<link[^>]+href=['"]?https:\/\/fonts\.bunny\.net['"]?[^>]+rel=['"]?preconnect['"]?[^>]*>/,
      // https://api.fontshare.com
      /<link[^>]+rel=['"]?preconnect['"]?[^>]+href=['"]?https:\/\/api\.fontshare\.com['"]?[^>]*>/,
      /<link[^>]+href=['"]?https:\/\/api\.fontshare\.com['"]?[^>]+rel=['"]?preconnect['"]?[^>]*>/
    ];
  }
  parse(html) {
    const webfontUrls = /* @__PURE__ */ new Set();
    for (const regex of this.webfontRegexes) {
      const matches = html.matchAll(regex);
      if (matches) {
        for (const match of matches) {
          webfontUrls.add(match[1]);
        }
      }
    }
    return webfontUrls;
  }
  removeTags(html) {
    html = this.removePreconnectTags(html);
    html = this.removeWebfontTags(html);
    return html;
  }
  removePreconnectTags(html) {
    for (const regex of this.preconnectRegexes) {
      const removeRegex = new RegExp("[ 	]*" + regex.source + "(\r\n|\r|\n)?", "g");
      html = html.replace(removeRegex, "");
    }
    return html;
  }
  removeWebfontTags(html) {
    for (const regex of this.webfontRegexes) {
      const removeRegex = new RegExp("[ 	]*" + regex.source + "(\r\n|\r|\n)?", "g");
      html = html.replace(removeRegex, "");
    }
    return html;
  }
};

// src/logger.ts
var import_process = require("process");
var import_picocolors2 = __toESM(require("picocolors"));
var Logger = class {
  setResolvedLogger(resolvedLogger) {
    this.resolvedLogger = resolvedLogger;
  }
  isTty() {
    return import_process.stdout.isTTY && !import_process.env.CI;
  }
  info(output, withPrefix = true) {
    var _a;
    this.clearLine();
    (_a = this.resolvedLogger) == null ? void 0 : _a.info((withPrefix ? this.prefix() : "") + output);
  }
  error(output, withPrefix = true) {
    var _a;
    this.clearLine();
    (_a = this.resolvedLogger) == null ? void 0 : _a.error((withPrefix ? this.prefix() : "") + output);
  }
  clearLine() {
    if (this.isTty()) {
      import_process.stdout.clearLine(0);
      import_process.stdout.cursorTo(0);
    }
  }
  flashLine(output, withPrefix = true) {
    if (this.isTty()) {
      this.clearLine();
      output = (withPrefix ? this.prefix() : "") + output;
      if (output.length < import_process.stdout.columns) {
        import_process.stdout.write(output);
      } else {
        import_process.stdout.write(output.substring(0, import_process.stdout.columns - 1));
      }
      if (this.flashTimeout) {
        clearTimeout(this.flashTimeout);
      }
      this.flashTimeout = setTimeout(() => {
        this.clearLine();
      }, 500);
    } else {
      this.info(output, withPrefix);
    }
  }
  prefix() {
    return import_picocolors2.default.dim("[webfont-dl] ");
  }
};

// src/default-options.ts
var defaultOptions = {
  injectAsStyleTag: true,
  minifyCss: true,
  async: true,
  cache: true,
  proxy: false
};
var getOptionsWithDefaults = (options = {}) => {
  return __spreadValues(__spreadValues({}, defaultOptions), options);
};

// src/index.ts
var import_axios2 = require("axios");
function viteWebfontDownload(_webfontUrls, _options) {
  if (!Array.isArray(_webfontUrls) && typeof _webfontUrls !== "string") {
    _webfontUrls = [];
  }
  if (typeof _webfontUrls === "string" && _webfontUrls !== "") {
    _webfontUrls = [_webfontUrls];
  }
  const webfontUrls = new Set(_webfontUrls || []);
  const webfontUrlsIndex = /* @__PURE__ */ new Set([]);
  const webfontUrlsCss = /* @__PURE__ */ new Set([]);
  const options = getOptionsWithDefaults(_options);
  let fonts = {};
  const cssFilename = "webfonts.css";
  const fontUrlsDevMap = /* @__PURE__ */ new Map();
  const logger = new Logger();
  const downloader = new Downloader(options, logger);
  const fileCache = new FileCache(options);
  const cssLoader = new CssLoader(options, logger, downloader, fileCache);
  const cssParser = new CssParser();
  const cssTransformer = new CssTransformer();
  const cssInjector = new CssInjector(options);
  const fontLoader = new FontLoader(logger, downloader, fileCache);
  const indexHtmlProcessor = new IndexHtmlProcessor();
  let viteDevServer;
  let pluginContext;
  let resolvedConfig;
  let base;
  let assetsDir;
  let indexHtmlContent;
  let indexHtmlPath;
  let cssContent = "";
  let cssPath;
  const collectWebfontsFromIndexHtml = (indexHtml) => {
    webfontUrlsIndex.clear();
    for (const webfontUrl of indexHtmlProcessor.parse(indexHtml)) {
      webfontUrlsIndex.add(webfontUrl);
    }
  };
  const collectWebfontsFromBundleCss = (bundle) => {
    webfontUrlsCss.clear();
    for (const path in bundle) {
      if (path.match(/\.css$/)) {
        let bundleCssContent = bundle[path].source.toString();
        const parsedBundleCss = cssParser.parseBundleCss(
          bundleCssContent,
          base,
          assetsDir
        );
        if (parsedBundleCss.matchedCssParts.length) {
          fonts = __spreadValues(__spreadValues({}, fonts), parsedBundleCss.fonts);
          parsedBundleCss.webfontUrlsCss.forEach((url) => {
            webfontUrlsCss.add(url);
          });
          parsedBundleCss.matchedCssParts.forEach((cssPart) => {
            bundleCssContent = bundleCssContent.replaceAll(cssPart, "");
            cssContent += cssPart + "\n";
          });
          bundle[path].source = bundleCssContent;
          cssContent = cssLoader.formatCss(
            cssContent,
            !!viteDevServer
          );
        }
      }
    }
  };
  const downloadWebfontCss = () => __async(this, null, function* () {
    cssContent = "";
    const started = Date.now();
    const allWebfontUrls = /* @__PURE__ */ new Set([
      ...webfontUrls,
      ...webfontUrlsIndex,
      ...webfontUrlsCss
    ]);
    if (allWebfontUrls.size) {
      cssContent += yield cssLoader.loadAll(allWebfontUrls, !!viteDevServer);
    }
    if (!viteDevServer) {
      logger.info(
        import_picocolors3.default.green("\u2713") + " " + allWebfontUrls.size.toString() + " webfont css downloaded. " + import_picocolors3.default.dim("(" + import_picocolors3.default.bold(toDuration(started)) + ", " + (options.cache !== false ? `cache hit: ${import_picocolors3.default.bold(toPercent(fileCache.hits.css, allWebfontUrls.size))}` : "cache disabled") + ")"),
        false
      );
    }
    return cssContent;
  });
  const parseFonts = (cssContent2) => {
    fonts = __spreadValues(__spreadValues({}, fonts), cssParser.parse(cssContent2, base, assetsDir));
  };
  const replaceFontUrls = () => {
    cssContent = cssTransformer.transform(cssContent, fonts);
  };
  const downloadFonts = () => __async(this, null, function* () {
    const started = Date.now();
    for (const fontFileName in fonts) {
      const font = fonts[fontFileName];
      const fontBinary = yield fontLoader.load(font.url);
      font.localPath = base + saveFile(
        fontFileName,
        fontBinary
      );
    }
    logger.info(
      import_picocolors3.default.green("\u2713") + " " + Object.keys(fonts).length.toString() + " webfonts downloaded. " + import_picocolors3.default.dim("(" + import_picocolors3.default.bold(toDuration(started)) + ", " + (options.cache !== false ? `cache hit: ${import_picocolors3.default.bold(toPercent(fileCache.hits.font, Object.keys(fonts).length))}` : "cache disabled") + ")"),
      false
    );
  });
  const downloadFont = (url) => __async(this, null, function* () {
    const font = fontLoader.load(url);
    logger.clearLine();
    return font;
  });
  const loadAndPrepareDevFonts = () => __async(this, null, function* () {
    parseFonts(yield downloadWebfontCss());
    replaceFontUrls();
    fontUrlsDevMap.clear();
    for (const fontFileName in fonts) {
      const font = fonts[fontFileName];
      fontUrlsDevMap.set(font.localPath, font.url);
    }
  });
  const saveCss = () => {
    cssPath = saveFile(
      cssFilename,
      cssContent
    );
  };
  const saveFile = (fileName, source) => {
    const ref = pluginContext.emitFile({
      name: fileName,
      type: "asset",
      source
    });
    return pluginContext.getFileName(ref);
  };
  const injectToHtml = (html, cssContent2) => {
    if (viteDevServer || options.injectAsStyleTag === false) {
      return cssInjector.injectAsStylesheet(html, base, cssPath);
    }
    return cssInjector.injectAsStyleTag(html, cssContent2);
  };
  const toDuration = (started) => {
    return (Date.now() - started).toLocaleString() + " ms";
  };
  const toPercent = (value, total) => {
    return (Math.round(value / total * 100 * 100) / 100).toFixed(2) + "%";
  };
  return {
    name: "vite-plugin-webfont-dl",
    enforce: "post",
    configResolved(_resolvedConfig) {
      resolvedConfig = _resolvedConfig;
      base = resolvedConfig.base;
      assetsDir = resolvedConfig.build.assetsDir;
      cssPath = assetsDir + "/" + cssFilename;
      if (resolvedConfig.build.minify === false && (_options == null ? void 0 : _options.minifyCss) !== true) {
        options.minifyCss = false;
      }
      logger.setResolvedLogger(resolvedConfig.logger);
    },
    configureServer(_viteDevServer) {
      viteDevServer = _viteDevServer;
      assetsDir = "@webfonts";
      cssPath = assetsDir + "/" + cssFilename;
      const handleDevServerWebfontsCss = (req, res) => {
        void (() => __async(this, null, function* () {
          res.setHeader("Content-Type", "text/css");
          try {
            yield loadAndPrepareDevFonts();
            res.end(cssContent);
          } catch (error) {
            logger.error(
              import_picocolors3.default.red(error.message)
            );
            res.statusCode = 502;
            res.setHeader("X-Error", error.message.replace(/^Error: /, ""));
            res.end();
          }
        }))();
      };
      const handleDevServerWebfont = (req, res) => {
        void (() => __async(this, null, function* () {
          var _a2;
          const url = (_a2 = req.originalUrl) == null ? void 0 : _a2.replace(/[?#].*$/, "");
          res.setHeader("Access-Control-Allow-Origin", "*");
          res.end(
            yield downloadFont(
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              fontUrlsDevMap.get(url)
            )
          );
        }))();
      };
      viteDevServer.middlewares.use(
        base + cssPath,
        // /@webfonts/webfonts.css
        handleDevServerWebfontsCss
      );
      viteDevServer.middlewares.use(
        base + cssFilename,
        // /webfonts.css (Laravel Vite Plugin)
        handleDevServerWebfontsCss
      );
      viteDevServer.middlewares.use((req, res, next) => {
        var _a2;
        const url = (_a2 = req.originalUrl) == null ? void 0 : _a2.replace(/[?#].*$/, "");
        if (!url) {
          return next();
        }
        if (
          // /assets/xxx.woff2
          url.match(/\.(?:woff2?|eot|ttf|otf|svg)$/) && fontUrlsDevMap.has(url)
        ) {
          handleDevServerWebfont(req, res);
        } else {
          next();
        }
      });
    },
    transformIndexHtml(html, ctx) {
      indexHtmlContent = html;
      indexHtmlPath = ctx.path.replace(/^\//, "");
      if (viteDevServer) {
        collectWebfontsFromIndexHtml(html);
        html = indexHtmlProcessor.removeTags(html);
        html = injectToHtml(html);
      }
      return html;
    },
    generateBundle(_options2, bundle) {
      return __async(this, null, function* () {
        pluginContext = this;
        if (indexHtmlContent !== void 0) {
          collectWebfontsFromIndexHtml(indexHtmlContent);
        }
        collectWebfontsFromBundleCss(bundle);
        try {
          parseFonts(yield downloadWebfontCss());
          yield downloadFonts();
          replaceFontUrls();
          if (options.injectAsStyleTag === false || indexHtmlContent === void 0) {
            saveCss();
          }
          const asset = bundle[indexHtmlPath];
          if (asset !== void 0) {
            indexHtmlContent = indexHtmlProcessor.removeTags(asset.source);
            indexHtmlContent = injectToHtml(indexHtmlContent, cssContent);
            asset.source = indexHtmlContent;
          }
        } catch (error) {
          logger.error(
            import_picocolors3.default.red(error.message)
          );
          if (error instanceof import_axios2.AxiosError) {
            if (error.request instanceof import_http2.ClientRequest) {
              logger.error(
                import_picocolors3.default.red(`${error.request.method} ${error.request.protocol}//${error.request.host}${error.request.path}`)
              );
            }
          }
        }
      });
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ViteWebfontDownload,
  viteWebfontDl,
  viteWebfontDownload,
  webfontDl,
  webfontDownload
});
