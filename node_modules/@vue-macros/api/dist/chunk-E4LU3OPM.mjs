import {
  tsFileCache
} from "./chunk-5FIR3URH.mjs";

// src/resolve.ts
import { existsSync } from "fs";
import { readFile } from "fs/promises";
import path from "path";
var RollupResolve = () => {
  const referencedFiles = /* @__PURE__ */ new Map();
  function collectReferencedFile(importer, file) {
    if (!importer)
      return;
    if (!referencedFiles.has(file)) {
      referencedFiles.set(file, /* @__PURE__ */ new Set([importer]));
    } else {
      referencedFiles.get(file).add(importer);
    }
  }
  const resolveCache = /* @__PURE__ */ new Map();
  function withResolveCache(id, importer, result) {
    if (!resolveCache.has(importer)) {
      resolveCache.set(importer, /* @__PURE__ */ new Map([[id, result]]));
      return result;
    }
    resolveCache.get(importer).set(id, result);
    return result;
  }
  const resolve = (ctx) => async (id, importer) => {
    var _a;
    async function tryPkgEntry() {
      var _a2;
      try {
        const pkgPath = (_a2 = await ctx.resolve(`${id}/package.json`, importer)) == null ? void 0 : _a2.id;
        if (!pkgPath)
          return;
        const pkg = JSON.parse(await readFile(pkgPath, "utf-8"));
        const types = pkg.types || pkg.typings;
        if (!types)
          return;
        const entry = path.resolve(pkgPath, "..", types);
        return existsSync(entry) ? entry : void 0;
      } catch {
      }
    }
    const tryResolve = async (id2) => {
      var _a2, _b;
      try {
        return ((_a2 = await ctx.resolve(id2, importer)) == null ? void 0 : _a2.id) || ((_b = await ctx.resolve(`${id2}.d`, importer)) == null ? void 0 : _b.id);
      } catch {
      }
      return;
    };
    const cached = (_a = resolveCache.get(importer)) == null ? void 0 : _a.get(id);
    if (cached)
      return cached;
    if (!id.startsWith(".")) {
      const entry = await tryPkgEntry();
      if (entry)
        return withResolveCache(id, importer, entry);
    }
    let resolved = await tryResolve(id);
    if (!resolved)
      return;
    if (existsSync(resolved)) {
      collectReferencedFile(importer, resolved);
      return withResolveCache(id, importer, resolved);
    }
    resolved = await tryResolve(resolved);
    if (resolved && existsSync(resolved)) {
      collectReferencedFile(importer, resolved);
      return withResolveCache(id, importer, resolved);
    }
  };
  const handleHotUpdate = ({
    file,
    server,
    modules
  }) => {
    const cache = /* @__PURE__ */ new Map();
    function getAffectedModules(file2) {
      if (cache.has(file2))
        return cache.get(file2);
      if (!referencedFiles.has(file2))
        return /* @__PURE__ */ new Set([]);
      const modules2 = /* @__PURE__ */ new Set([]);
      cache.set(file2, modules2);
      for (const importer of referencedFiles.get(file2)) {
        const mods = server.moduleGraph.getModulesByFile(importer);
        if (mods)
          mods.forEach((m) => modules2.add(m));
        getAffectedModules(importer).forEach((m) => modules2.add(m));
      }
      return modules2;
    }
    if (tsFileCache[file])
      delete tsFileCache[file];
    const affected = getAffectedModules(file);
    return [...modules, ...affected];
  };
  return {
    resolve,
    handleHotUpdate
  };
};

export {
  RollupResolve
};
