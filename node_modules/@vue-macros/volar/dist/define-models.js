// src/define-models.ts
var import_common = require("@vue-macros/common");
var import_language_core = require("@volar/language-core");

// src/common.ts
var import_muggle_string = require("muggle-string");
function getVueLibraryName(vueVersion) {
  return vueVersion < 2.7 ? "@vue/runtime-dom" : "vue";
}
function addProps(content, decl, vueLibName) {
  (0, import_muggle_string.replace)(
    content,
    /setup\(\) {/,
    "props: ({} as ",
    ...decl,
    "),\n",
    "setup() {"
  );
  content.push(
    `type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
`,
    `type __VLS_TypePropsToRuntimeProps<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? { type: import('${vueLibName}').PropType<__VLS_NonUndefinedable<T[K]>> } : { type: import('${vueLibName}').PropType<T[K]>, required: true } };
`
  );
  return true;
}
function addEmits(content, decl) {
  const idx = content.indexOf("setup() {\n");
  if (idx === -1)
    return false;
  (0, import_muggle_string.replace)(
    content,
    /setup\(\) {/,
    "emits: ({} as ",
    ...decl,
    "),\n",
    "setup() {"
  );
  return true;
}

// src/define-models.ts
function transformDefineModels({
  codes,
  sfc,
  typeArg,
  vueLibName,
  unified
}) {
  const source = sfc.scriptSetup.content.slice(typeArg.pos, typeArg.end);
  const seg = [
    source,
    "scriptSetup",
    typeArg.pos,
    import_language_core.FileRangeCapabilities.full
  ];
  mergeProps() || addProps(
    codes,
    ["__VLS_TypePropsToRuntimeProps<__VLS_ModelToProps<", seg, ">>"],
    vueLibName
  );
  mergeEmits() || addEmits(codes, ["__VLS_ModelToEmits<", seg, ">"]);
  codes.push(
    `type __VLS_GetPropKey<K> = K extends 'modelValue'${unified ? "" : " & never"} ? 'value' : K
    type __VLS_ModelToProps<T> = {
      [K in keyof T as __VLS_GetPropKey<K>]: T[K]
    }
    type __VLS_GetEventKey<K extends string | number> = K extends 'modelValue'${unified ? "" : " & never"} ? 'input' : \`update:\${K}\`
    type __VLS_ModelToEmits<T> = T extends Record<string | number, any> ? { [K in keyof T & (string | number) as __VLS_GetEventKey<K>]: (value: T[K]) => void } : T`
  );
  function mergeProps() {
    const idx = codes.indexOf("__VLS_TypePropsToRuntimeProps<");
    if (idx === -1)
      return false;
    codes.splice(idx + 2, 0, " & __VLS_ModelToProps<", seg, ">");
    return true;
  }
  function mergeEmits() {
    const idx = codes.indexOf(
      "emits: ({} as __VLS_UnionToIntersection<__VLS_ConstructorOverloads<"
    );
    if (idx === -1)
      return false;
    codes.splice(idx + 2, 1, ">> & __VLS_ModelToEmits<", seg, ">),\n");
    return true;
  }
}
function getTypeArg(ts, sfc) {
  function getCallArg(node) {
    var _a;
    if (!(ts.isCallExpression(node) && ts.isIdentifier(node.expression) && [import_common.DEFINE_MODELS, import_common.DEFINE_MODELS_DOLLAR].includes(node.expression.text) && ((_a = node.typeArguments) == null ? void 0 : _a.length) === 1))
      return void 0;
    return node.typeArguments[0];
  }
  const sourceFile = sfc.scriptSetupAst;
  return sourceFile.forEachChild((node) => {
    if (ts.isExpressionStatement(node)) {
      return getCallArg(node.expression);
    } else if (ts.isVariableStatement(node)) {
      return node.declarationList.forEachChild((decl) => {
        if (!ts.isVariableDeclaration(decl) || !decl.initializer)
          return;
        return getCallArg(decl.initializer);
      });
    }
  });
}
var plugin = ({
  modules: { typescript: ts },
  vueCompilerOptions
}) => {
  return {
    name: "vue-macros-define-models",
    version: 1,
    resolveEmbeddedFile(fileName, sfc, embeddedFile) {
      var _a;
      if (embeddedFile.kind !== import_language_core.FileKind.TypeScriptHostFile || !sfc.scriptSetup || !sfc.scriptSetupAst)
        return;
      const typeArg = getTypeArg(ts, sfc);
      if (!typeArg)
        return;
      const vueVersion = vueCompilerOptions.target;
      const vueLibName = getVueLibraryName(vueVersion);
      const unified = (vueVersion < 3 && ((_a = vueCompilerOptions == null ? void 0 : vueCompilerOptions.defineModels) == null ? void 0 : _a.unified)) ?? true;
      transformDefineModels({
        codes: embeddedFile.content,
        sfc,
        typeArg,
        vueLibName,
        unified
      });
    }
  };
};
module.exports = plugin;
