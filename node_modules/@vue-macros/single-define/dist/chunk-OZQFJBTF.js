"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/core/constants.ts
var _common = require('@vue-macros/common');
var PROPS_VARIABLE_NAME = `${_common.HELPER_PREFIX}props`;
var EMIT_VARIABLE_NAME = `${_common.HELPER_PREFIX}emit`;

// src/core/define-emit.ts

function mountEmits(emits) {
  const isAllWithoutOptions = emits.every(({ validator }) => !validator);
  if (isAllWithoutOptions) {
    return `[${emits.map(({ name }) => JSON.stringify(name)).join(", ")}]`;
  }
  return `{
      ${emits.map(
    ({ name, validator }) => `${JSON.stringify(name)}: ${validator || `null`}`
  ).join(",\n  ")}
    }`;
}
function transformDefineEmit({ setupAst, offset, s }) {
  const emits = [];
  _common.walkAST.call(void 0, setupAst, {
    enter(node, parent) {
      if (_common.isCallOf.call(void 0, node, _common.DEFINE_EMIT)) {
        const [name, validator] = node.arguments;
        let emitName;
        if (!name) {
          if (parent.type !== "VariableDeclarator" || parent.id.type !== "Identifier") {
            throw new Error(
              `A variable must be used to receive the return value of ${_common.DEFINE_EMIT}.`
            );
          }
          emitName = parent.id.name;
        } else if (name.type !== "StringLiteral") {
          throw new Error(
            `The first argument of ${_common.DEFINE_EMIT} must be a string literal.`
          );
        } else {
          emitName = name.value;
        }
        emits.push({
          name: emitName,
          validator: validator ? s.sliceNode(validator, { offset }) : void 0
        });
        s.overwriteNode(
          node,
          `(...args) => ${EMIT_VARIABLE_NAME}(${JSON.stringify(
            emitName
          )}, ...args)`,
          { offset }
        );
      }
    }
  });
  if (emits.length > 0) {
    s.prependLeft(
      offset,
      `
const ${EMIT_VARIABLE_NAME} = defineEmits(${mountEmits(emits)})
`
    );
  }
}

// src/core/define-prop.ts











var _api = require('@vue-macros/api');
async function mountProps({ id, scriptSetup, setupAst, isProduction }, props) {
  const isAllWithoutOptions = props.every(
    ({ definition, typeParameter }) => !definition && !typeParameter
  );
  if (isAllWithoutOptions) {
    return `[${props.map(({ name }) => JSON.stringify(name)).join(", ")}]`;
  }
  let propsString = "{\n";
  for (const { name, definition, typeParameter } of props) {
    propsString += `  ${JSON.stringify(name)}: `;
    let propDef;
    if (typeParameter && !isProduction) {
      const resolved = await _api.resolveTSReferencedType.call(void 0, {
        scope: {
          filePath: id,
          content: scriptSetup.content,
          ast: setupAst.body
        },
        type: typeParameter
      });
      if (resolved)
        propDef = `{ type: ${_api.toRuntimeTypeString.call(void 0, 
          await _api.inferRuntimeType.call(void 0, resolved)
        )} }`;
    }
    if (definition) {
      if (propDef) {
        propDef = `{ ...${propDef}, ...${definition} }`;
      } else {
        propDef = definition;
      }
    }
    propsString += `${propDef || "null"},
`;
  }
  propsString += "}";
  return propsString;
}
async function transformDefineProp(options) {
  const { setupAst, offset, s } = options;
  const props = [];
  _common.walkAST.call(void 0, setupAst, {
    enter(node, parent) {
      var _a;
      if (_common.isCallOf.call(void 0, node, _common.DEFINE_PROP)) {
        const [name, definition] = node.arguments;
        let propName;
        if (!name) {
          if (parent.type !== "VariableDeclarator" || parent.id.type !== "Identifier") {
            throw new Error(
              `A variable must be used to receive the return value of ${_common.DEFINE_PROP}.`
            );
          }
          propName = parent.id.name;
        } else if (name.type !== "StringLiteral") {
          throw new Error(
            `The first argument of ${_common.DEFINE_PROP} must be a string literal.`
          );
        } else {
          propName = name.value;
        }
        props.push({
          name: propName,
          definition: definition ? s.sliceNode(definition, { offset }) : void 0,
          typeParameter: (_a = node.typeParameters) == null ? void 0 : _a.params[0]
        });
        s.overwriteNode(
          node,
          `${_common.HELPER_PREFIX}computed(() => ${PROPS_VARIABLE_NAME}[${JSON.stringify(
            propName
          )}])`,
          { offset }
        );
      }
    }
  });
  if (props.length > 0) {
    _common.importHelperFn.call(void 0, s, offset, "computed", "vue");
    s.prependLeft(
      offset,
      `
const ${PROPS_VARIABLE_NAME} = defineProps(${await mountProps(
        options,
        props
      )})
`
    );
  }
}

// src/core/index.ts







async function transformDefineSingle(code, id, isProduction) {
  const { scriptSetup, getSetupAst } = _common.parseSFC.call(void 0, code, id);
  if (!scriptSetup)
    return;
  const offset = scriptSetup.loc.start.offset;
  const s = new (0, _common.MagicString)(code);
  const setupAst = getSetupAst();
  const options = {
    id,
    s,
    offset,
    scriptSetup,
    setupAst,
    isProduction
  };
  if (code.includes(_common.DEFINE_PROP)) {
    await transformDefineProp(options);
  }
  if (code.includes(_common.DEFINE_EMIT)) {
    await transformDefineEmit(options);
  }
  return _common.getTransformResult.call(void 0, s, id);
}







exports.PROPS_VARIABLE_NAME = PROPS_VARIABLE_NAME; exports.EMIT_VARIABLE_NAME = EMIT_VARIABLE_NAME; exports.transformDefineEmit = transformDefineEmit; exports.transformDefineProp = transformDefineProp; exports.transformDefineSingle = transformDefineSingle;
