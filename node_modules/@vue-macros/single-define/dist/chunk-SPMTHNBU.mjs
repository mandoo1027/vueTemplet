// src/core/constants.ts
import { HELPER_PREFIX } from "@vue-macros/common";
var PROPS_VARIABLE_NAME = `${HELPER_PREFIX}props`;
var EMIT_VARIABLE_NAME = `${HELPER_PREFIX}emit`;

// src/core/define-emit.ts
import { DEFINE_EMIT, isCallOf, walkAST } from "@vue-macros/common";
function mountEmits(emits) {
  const isAllWithoutOptions = emits.every(({ validator }) => !validator);
  if (isAllWithoutOptions) {
    return `[${emits.map(({ name }) => JSON.stringify(name)).join(", ")}]`;
  }
  return `{
      ${emits.map(
    ({ name, validator }) => `${JSON.stringify(name)}: ${validator || `null`}`
  ).join(",\n  ")}
    }`;
}
function transformDefineEmit({ setupAst, offset, s }) {
  const emits = [];
  walkAST(setupAst, {
    enter(node, parent) {
      if (isCallOf(node, DEFINE_EMIT)) {
        const [name, validator] = node.arguments;
        let emitName;
        if (!name) {
          if (parent.type !== "VariableDeclarator" || parent.id.type !== "Identifier") {
            throw new Error(
              `A variable must be used to receive the return value of ${DEFINE_EMIT}.`
            );
          }
          emitName = parent.id.name;
        } else if (name.type !== "StringLiteral") {
          throw new Error(
            `The first argument of ${DEFINE_EMIT} must be a string literal.`
          );
        } else {
          emitName = name.value;
        }
        emits.push({
          name: emitName,
          validator: validator ? s.sliceNode(validator, { offset }) : void 0
        });
        s.overwriteNode(
          node,
          `(...args) => ${EMIT_VARIABLE_NAME}(${JSON.stringify(
            emitName
          )}, ...args)`,
          { offset }
        );
      }
    }
  });
  if (emits.length > 0) {
    s.prependLeft(
      offset,
      `
const ${EMIT_VARIABLE_NAME} = defineEmits(${mountEmits(emits)})
`
    );
  }
}

// src/core/define-prop.ts
import {
  DEFINE_PROP,
  HELPER_PREFIX as HELPER_PREFIX2,
  importHelperFn,
  isCallOf as isCallOf2,
  walkAST as walkAST2
} from "@vue-macros/common";
import {
  inferRuntimeType,
  resolveTSReferencedType,
  toRuntimeTypeString
} from "@vue-macros/api";
async function mountProps({ id, scriptSetup, setupAst, isProduction }, props) {
  const isAllWithoutOptions = props.every(
    ({ definition, typeParameter }) => !definition && !typeParameter
  );
  if (isAllWithoutOptions) {
    return `[${props.map(({ name }) => JSON.stringify(name)).join(", ")}]`;
  }
  let propsString = "{\n";
  for (const { name, definition, typeParameter } of props) {
    propsString += `  ${JSON.stringify(name)}: `;
    let propDef;
    if (typeParameter && !isProduction) {
      const resolved = await resolveTSReferencedType({
        scope: {
          filePath: id,
          content: scriptSetup.content,
          ast: setupAst.body
        },
        type: typeParameter
      });
      if (resolved)
        propDef = `{ type: ${toRuntimeTypeString(
          await inferRuntimeType(resolved)
        )} }`;
    }
    if (definition) {
      if (propDef) {
        propDef = `{ ...${propDef}, ...${definition} }`;
      } else {
        propDef = definition;
      }
    }
    propsString += `${propDef || "null"},
`;
  }
  propsString += "}";
  return propsString;
}
async function transformDefineProp(options) {
  const { setupAst, offset, s } = options;
  const props = [];
  walkAST2(setupAst, {
    enter(node, parent) {
      var _a;
      if (isCallOf2(node, DEFINE_PROP)) {
        const [name, definition] = node.arguments;
        let propName;
        if (!name) {
          if (parent.type !== "VariableDeclarator" || parent.id.type !== "Identifier") {
            throw new Error(
              `A variable must be used to receive the return value of ${DEFINE_PROP}.`
            );
          }
          propName = parent.id.name;
        } else if (name.type !== "StringLiteral") {
          throw new Error(
            `The first argument of ${DEFINE_PROP} must be a string literal.`
          );
        } else {
          propName = name.value;
        }
        props.push({
          name: propName,
          definition: definition ? s.sliceNode(definition, { offset }) : void 0,
          typeParameter: (_a = node.typeParameters) == null ? void 0 : _a.params[0]
        });
        s.overwriteNode(
          node,
          `${HELPER_PREFIX2}computed(() => ${PROPS_VARIABLE_NAME}[${JSON.stringify(
            propName
          )}])`,
          { offset }
        );
      }
    }
  });
  if (props.length > 0) {
    importHelperFn(s, offset, "computed", "vue");
    s.prependLeft(
      offset,
      `
const ${PROPS_VARIABLE_NAME} = defineProps(${await mountProps(
        options,
        props
      )})
`
    );
  }
}

// src/core/index.ts
import {
  DEFINE_EMIT as DEFINE_EMIT2,
  DEFINE_PROP as DEFINE_PROP2,
  MagicString,
  getTransformResult,
  parseSFC
} from "@vue-macros/common";
async function transformDefineSingle(code, id, isProduction) {
  const { scriptSetup, getSetupAst } = parseSFC(code, id);
  if (!scriptSetup)
    return;
  const offset = scriptSetup.loc.start.offset;
  const s = new MagicString(code);
  const setupAst = getSetupAst();
  const options = {
    id,
    s,
    offset,
    scriptSetup,
    setupAst,
    isProduction
  };
  if (code.includes(DEFINE_PROP2)) {
    await transformDefineProp(options);
  }
  if (code.includes(DEFINE_EMIT2)) {
    await transformDefineEmit(options);
  }
  return getTransformResult(s, id);
}

export {
  PROPS_VARIABLE_NAME,
  EMIT_VARIABLE_NAME,
  transformDefineEmit,
  transformDefineProp,
  transformDefineSingle
};
